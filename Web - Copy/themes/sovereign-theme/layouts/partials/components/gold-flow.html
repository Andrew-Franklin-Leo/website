<div id="sovereign-gold-flow-container"></div>

<style>
    #sovereign-gold-flow-container {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 0;
        /* Above background, but below interactive elements if possible, or pointer-events: none */
        pointer-events: none;
        overflow: hidden;
    }

    .gold-flow-svg {
        width: 100%;
        height: 100%;
        filter: drop-shadow(0 0 2px rgba(212, 175, 55, 0.3));
    }

    .flow-path {
        fill: none;
        stroke: url(#goldGradient);
        stroke-width: 1.5;
        stroke-linecap: round;
        opacity: 0.3;
        /* Base wireframe visibility */
    }

    .flow-pulse {
        fill: none;
        stroke: url(#goldPulseGradient);
        stroke-width: 3;
        stroke-linecap: round;
        stroke-dasharray: 100, 2000;
        /* Pulse length, Gap */
        stroke-dashoffset: 0;
        animation: flowPulse 8s cubic-bezier(0.4, 0.0, 0.2, 1) infinite;
        opacity: 0.9;
        mix-blend-mode: overlay;
    }

    @keyframes flowPulse {
        0% {
            transform: translateZ(0);
            stroke-dashoffset: 2100;
            opacity: 0;
        }

        10% {
            opacity: 1;
        }

        90% {
            opacity: 1;
        }

        100% {
            transform: translateZ(0);
            stroke-dashoffset: -2100;
            opacity: 0;
        }
    }
</style>

<script>
    (function () {
        /**
         * SOVEREIGN CONDUCTIVE PATHS
         * Principle: Gold defines the flow of attention.
         * Implementation: Dynamically draws SVG lines connecting key UI nodes.
         */

        const container = document.getElementById('sovereign-gold-flow-container');
        let svg = null;

        function createSVG() {
            if (svg) svg.remove();

            svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
            svg.classList.add('gold-flow-svg');

            // Define Gradients
            const defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");

            // Base Wireframe Gradient (Dark/Subtle)
            const grad = document.createElementNS("http://www.w3.org/2000/svg", "linearGradient");
            grad.id = "goldGradient";
            grad.innerHTML = `
                <stop offset="0%" stop-color="#785C15" stop-opacity="0.2"/>
                <stop offset="50%" stop-color="#D4AF37" stop-opacity="0.4"/>
                <stop offset="100%" stop-color="#785C15" stop-opacity="0.2"/>
            `;

            // Pulse Gradient (Bright/Liquid)
            const pulseGrad = document.createElementNS("http://www.w3.org/2000/svg", "linearGradient");
            pulseGrad.id = "goldPulseGradient";
            pulseGrad.innerHTML = `
                <stop offset="0%" stop-color="rgba(212, 175, 55, 0)"/>
                <stop offset="50%" stop-color="#FFD700" stop-opacity="1"/>
                <stop offset="100%" stop-color="rgba(212, 175, 55, 0)"/>
            `;

            defs.appendChild(grad);
            defs.appendChild(pulseGrad);
            svg.appendChild(defs);
            container.appendChild(svg);
        }

        function getCenter(el) {
            const rect = el.getBoundingClientRect();
            // We need coords relative to the document, not viewport
            const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
            return {
                x: rect.left + rect.width / 2,
                y: rect.top + scrollTop + rect.height / 2
            };
        }

        function drawBezier(p1, p2) {
            const path = document.createElementNS("http://www.w3.org/2000/svg", "path");

            // Control points for a natural "slack" or "flow" curve
            // Instead of straight lines, we curve slightly downwards or sideways
            const dist = Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
            const curveFactor = dist * 0.2; // Curve magnitude related to distance

            // Force a slight "S" curve or "Gravity" sag
            const cp1 = { x: p1.x, y: p1.y + curveFactor };
            const cp2 = { x: p2.x, y: p2.y - curveFactor };

            const d = `M ${p1.x} ${p1.y} C ${cp1.x} ${cp1.y}, ${cp2.x} ${cp2.y}, ${p2.x} ${p2.y}`;
            path.setAttribute("d", d);
            path.classList.add("flow-path");

            // Create a duplicate for the pulse effect
            const pulse = path.cloneNode();
            pulse.classList.remove("flow-path");
            pulse.classList.add("flow-pulse");
            // Randomize animation delay so pulses aren't synchronized
            pulse.style.animationDelay = `${Math.random() * 5}s`;
            // Adjust stroke dasharray based on path length approx
            pulse.style.strokeDasharray = `${dist * 0.3} ${dist * 2}`;

            svg.appendChild(path);
            svg.appendChild(pulse);
        }

        function connectNodes() {
            // Define the Golden Path (The "Conductive" narrative)
            // Hero Title -> CTA -> Bento 1 -> Bento 3 -> Footer

            const title = document.querySelector('h1.hero-title');
            const cta = document.querySelector('.hero-cta');
            const bentos = document.querySelectorAll('.bento-card');
            const footer = document.querySelector('footer');

            // Robustness check
            if (!title || !cta || bentos.length === 0) return;

            createSVG();

            // 1. Title to CTA
            drawBezier(getCenter(title), getCenter(cta));

            // 2. CTA to First Bento
            drawBezier(getCenter(cta), getCenter(bentos[0]));

            // 3. Connect Bentos in a chain (1 -> 2, 2 -> 3, etc.)
            // We only connect a few to avoid clutter - guiding the eye down
            for (let i = 0; i < Math.min(bentos.length - 1, 3); i++) {
                drawBezier(getCenter(bentos[i]), getCenter(bentos[i + 1]));
            }

            // 4. Last Bento to Footer logo/text
            if (footer) {
                // Approximate footer center top
                const lastBento = bentos[Math.min(bentos.length - 1, 3)];
                const footerRect = footer.getBoundingClientRect();
                const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
                const footerPoint = {
                    x: footerRect.left + footerRect.width / 2,
                    y: footerRect.top + scrollTop + 40
                };
                drawBezier(getCenter(lastBento), footerPoint);
            }
        }

        // Initialize on Load and Resize
        window.addEventListener('load', connectNodes);
        // Debounced resize
        let timeout;
        window.addEventListener('resize', () => {
            clearTimeout(timeout);
            timeout = setTimeout(connectNodes, 200);
        });

        // Also run immediately in case DOM is ready
        if (document.readyState !== 'loading') connectNodes();

    })();
</script>